/**
 * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */

package BoardService.model.impl;

import BoardService.model.TBL;
import BoardService.model.TBLModel;
import BoardService.model.TBLSoap;

import com.liferay.expando.kernel.model.ExpandoBridge;
import com.liferay.expando.kernel.util.ExpandoBridgeFactoryUtil;
import com.liferay.petra.string.StringBundler;
import com.liferay.portal.kernel.bean.AutoEscapeBeanHandler;
import com.liferay.portal.kernel.json.JSON;
import com.liferay.portal.kernel.model.CacheModel;
import com.liferay.portal.kernel.model.ModelWrapper;
import com.liferay.portal.kernel.model.impl.BaseModelImpl;
import com.liferay.portal.kernel.service.ServiceContext;
import com.liferay.portal.kernel.util.GetterUtil;
import com.liferay.portal.kernel.util.ProxyUtil;

import java.io.Serializable;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;

import java.sql.Types;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.Function;

/**
 * The base model implementation for the TBL service. Represents a row in the &quot;HHL_PROJECT_TBL&quot; database table, with each column mapped to a property of this class.
 *
 * <p>
 * This implementation and its corresponding interface <code>TBLModel</code> exist only as a container for the default property accessors generated by ServiceBuilder. Helper methods and all application logic should be put in {@link TBLImpl}.
 * </p>
 *
 * @author Brian Wing Shun Chan
 * @see TBLImpl
 * @generated
 */
@JSON(strict = true)
public class TBLModelImpl extends BaseModelImpl<TBL> implements TBLModel {

	/*
	 * NOTE FOR DEVELOPERS:
	 *
	 * Never modify or reference this class directly. All methods that expect a tbl model instance should use the <code>TBL</code> interface instead.
	 */
	public static final String TABLE_NAME = "HHL_PROJECT_TBL";

	public static final Object[][] TABLE_COLUMNS = {
		{"bno", Types.BIGINT}, {"subject", Types.VARCHAR},
		{"writer", Types.VARCHAR}, {"contents", Types.VARCHAR},
		{"regDate", Types.VARCHAR}, {"hit", Types.INTEGER}
	};

	public static final Map<String, Integer> TABLE_COLUMNS_MAP =
		new HashMap<String, Integer>();

	static {
		TABLE_COLUMNS_MAP.put("bno", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("subject", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("writer", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("contents", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("regDate", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("hit", Types.INTEGER);
	}

	public static final String TABLE_SQL_CREATE =
		"create table HHL_PROJECT_TBL (bno LONG not null primary key,subject VARCHAR(75) null,writer VARCHAR(75) null,contents VARCHAR(75) null,regDate VARCHAR(75) null,hit INTEGER)";

	public static final String TABLE_SQL_DROP = "drop table HHL_PROJECT_TBL";

	public static final String ORDER_BY_JPQL = " ORDER BY tbl.bno ASC";

	public static final String ORDER_BY_SQL =
		" ORDER BY HHL_PROJECT_TBL.bno ASC";

	public static final String DATA_SOURCE = "liferayDataSource";

	public static final String SESSION_FACTORY = "liferaySessionFactory";

	public static final String TX_MANAGER = "liferayTransactionManager";

	public static final long CONTENTS_COLUMN_BITMASK = 1L;

	public static final long SUBJECT_COLUMN_BITMASK = 2L;

	public static final long WRITER_COLUMN_BITMASK = 4L;

	public static final long BNO_COLUMN_BITMASK = 8L;

	public static void setEntityCacheEnabled(boolean entityCacheEnabled) {
		_entityCacheEnabled = entityCacheEnabled;
	}

	public static void setFinderCacheEnabled(boolean finderCacheEnabled) {
		_finderCacheEnabled = finderCacheEnabled;
	}

	/**
	 * Converts the soap model instance into a normal model instance.
	 *
	 * @param soapModel the soap model instance to convert
	 * @return the normal model instance
	 */
	public static TBL toModel(TBLSoap soapModel) {
		if (soapModel == null) {
			return null;
		}

		TBL model = new TBLImpl();

		model.setBno(soapModel.getBno());
		model.setSubject(soapModel.getSubject());
		model.setWriter(soapModel.getWriter());
		model.setContents(soapModel.getContents());
		model.setRegDate(soapModel.getRegDate());
		model.setHit(soapModel.getHit());

		return model;
	}

	/**
	 * Converts the soap model instances into normal model instances.
	 *
	 * @param soapModels the soap model instances to convert
	 * @return the normal model instances
	 */
	public static List<TBL> toModels(TBLSoap[] soapModels) {
		if (soapModels == null) {
			return null;
		}

		List<TBL> models = new ArrayList<TBL>(soapModels.length);

		for (TBLSoap soapModel : soapModels) {
			models.add(toModel(soapModel));
		}

		return models;
	}

	public TBLModelImpl() {
	}

	@Override
	public long getPrimaryKey() {
		return _bno;
	}

	@Override
	public void setPrimaryKey(long primaryKey) {
		setBno(primaryKey);
	}

	@Override
	public Serializable getPrimaryKeyObj() {
		return _bno;
	}

	@Override
	public void setPrimaryKeyObj(Serializable primaryKeyObj) {
		setPrimaryKey(((Long)primaryKeyObj).longValue());
	}

	@Override
	public Class<?> getModelClass() {
		return TBL.class;
	}

	@Override
	public String getModelClassName() {
		return TBL.class.getName();
	}

	@Override
	public Map<String, Object> getModelAttributes() {
		Map<String, Object> attributes = new HashMap<String, Object>();

		Map<String, Function<TBL, Object>> attributeGetterFunctions =
			getAttributeGetterFunctions();

		for (Map.Entry<String, Function<TBL, Object>> entry :
				attributeGetterFunctions.entrySet()) {

			String attributeName = entry.getKey();
			Function<TBL, Object> attributeGetterFunction = entry.getValue();

			attributes.put(
				attributeName, attributeGetterFunction.apply((TBL)this));
		}

		attributes.put("entityCacheEnabled", isEntityCacheEnabled());
		attributes.put("finderCacheEnabled", isFinderCacheEnabled());

		return attributes;
	}

	@Override
	public void setModelAttributes(Map<String, Object> attributes) {
		Map<String, BiConsumer<TBL, Object>> attributeSetterBiConsumers =
			getAttributeSetterBiConsumers();

		for (Map.Entry<String, Object> entry : attributes.entrySet()) {
			String attributeName = entry.getKey();

			BiConsumer<TBL, Object> attributeSetterBiConsumer =
				attributeSetterBiConsumers.get(attributeName);

			if (attributeSetterBiConsumer != null) {
				attributeSetterBiConsumer.accept((TBL)this, entry.getValue());
			}
		}
	}

	public Map<String, Function<TBL, Object>> getAttributeGetterFunctions() {
		return _attributeGetterFunctions;
	}

	public Map<String, BiConsumer<TBL, Object>>
		getAttributeSetterBiConsumers() {

		return _attributeSetterBiConsumers;
	}

	private static Function<InvocationHandler, TBL>
		_getProxyProviderFunction() {

		Class<?> proxyClass = ProxyUtil.getProxyClass(
			TBL.class.getClassLoader(), TBL.class, ModelWrapper.class);

		try {
			Constructor<TBL> constructor =
				(Constructor<TBL>)proxyClass.getConstructor(
					InvocationHandler.class);

			return invocationHandler -> {
				try {
					return constructor.newInstance(invocationHandler);
				}
				catch (ReflectiveOperationException
							reflectiveOperationException) {

					throw new InternalError(reflectiveOperationException);
				}
			};
		}
		catch (NoSuchMethodException noSuchMethodException) {
			throw new InternalError(noSuchMethodException);
		}
	}

	private static final Map<String, Function<TBL, Object>>
		_attributeGetterFunctions;
	private static final Map<String, BiConsumer<TBL, Object>>
		_attributeSetterBiConsumers;

	static {
		Map<String, Function<TBL, Object>> attributeGetterFunctions =
			new LinkedHashMap<String, Function<TBL, Object>>();
		Map<String, BiConsumer<TBL, ?>> attributeSetterBiConsumers =
			new LinkedHashMap<String, BiConsumer<TBL, ?>>();

		attributeGetterFunctions.put("bno", TBL::getBno);
		attributeSetterBiConsumers.put(
			"bno", (BiConsumer<TBL, Long>)TBL::setBno);
		attributeGetterFunctions.put("subject", TBL::getSubject);
		attributeSetterBiConsumers.put(
			"subject", (BiConsumer<TBL, String>)TBL::setSubject);
		attributeGetterFunctions.put("writer", TBL::getWriter);
		attributeSetterBiConsumers.put(
			"writer", (BiConsumer<TBL, String>)TBL::setWriter);
		attributeGetterFunctions.put("contents", TBL::getContents);
		attributeSetterBiConsumers.put(
			"contents", (BiConsumer<TBL, String>)TBL::setContents);
		attributeGetterFunctions.put("regDate", TBL::getRegDate);
		attributeSetterBiConsumers.put(
			"regDate", (BiConsumer<TBL, String>)TBL::setRegDate);
		attributeGetterFunctions.put("hit", TBL::getHit);
		attributeSetterBiConsumers.put(
			"hit", (BiConsumer<TBL, Integer>)TBL::setHit);

		_attributeGetterFunctions = Collections.unmodifiableMap(
			attributeGetterFunctions);
		_attributeSetterBiConsumers = Collections.unmodifiableMap(
			(Map)attributeSetterBiConsumers);
	}

	@JSON
	@Override
	public long getBno() {
		return _bno;
	}

	@Override
	public void setBno(long bno) {
		_bno = bno;
	}

	@JSON
	@Override
	public String getSubject() {
		if (_subject == null) {
			return "";
		}
		else {
			return _subject;
		}
	}

	@Override
	public void setSubject(String subject) {
		_columnBitmask |= SUBJECT_COLUMN_BITMASK;

		if (_originalSubject == null) {
			_originalSubject = _subject;
		}

		_subject = subject;
	}

	public String getOriginalSubject() {
		return GetterUtil.getString(_originalSubject);
	}

	@JSON
	@Override
	public String getWriter() {
		if (_writer == null) {
			return "";
		}
		else {
			return _writer;
		}
	}

	@Override
	public void setWriter(String writer) {
		_columnBitmask |= WRITER_COLUMN_BITMASK;

		if (_originalWriter == null) {
			_originalWriter = _writer;
		}

		_writer = writer;
	}

	public String getOriginalWriter() {
		return GetterUtil.getString(_originalWriter);
	}

	@JSON
	@Override
	public String getContents() {
		if (_contents == null) {
			return "";
		}
		else {
			return _contents;
		}
	}

	@Override
	public void setContents(String contents) {
		_columnBitmask |= CONTENTS_COLUMN_BITMASK;

		if (_originalContents == null) {
			_originalContents = _contents;
		}

		_contents = contents;
	}

	public String getOriginalContents() {
		return GetterUtil.getString(_originalContents);
	}

	@JSON
	@Override
	public String getRegDate() {
		if (_regDate == null) {
			return "";
		}
		else {
			return _regDate;
		}
	}

	@Override
	public void setRegDate(String regDate) {
		_regDate = regDate;
	}

	@JSON
	@Override
	public int getHit() {
		return _hit;
	}

	@Override
	public void setHit(int hit) {
		_hit = hit;
	}

	public long getColumnBitmask() {
		return _columnBitmask;
	}

	@Override
	public ExpandoBridge getExpandoBridge() {
		return ExpandoBridgeFactoryUtil.getExpandoBridge(
			0, TBL.class.getName(), getPrimaryKey());
	}

	@Override
	public void setExpandoBridgeAttributes(ServiceContext serviceContext) {
		ExpandoBridge expandoBridge = getExpandoBridge();

		expandoBridge.setAttributes(serviceContext);
	}

	@Override
	public TBL toEscapedModel() {
		if (_escapedModel == null) {
			Function<InvocationHandler, TBL> escapedModelProxyProviderFunction =
				EscapedModelProxyProviderFunctionHolder.
					_escapedModelProxyProviderFunction;

			_escapedModel = escapedModelProxyProviderFunction.apply(
				new AutoEscapeBeanHandler(this));
		}

		return _escapedModel;
	}

	@Override
	public Object clone() {
		TBLImpl tblImpl = new TBLImpl();

		tblImpl.setBno(getBno());
		tblImpl.setSubject(getSubject());
		tblImpl.setWriter(getWriter());
		tblImpl.setContents(getContents());
		tblImpl.setRegDate(getRegDate());
		tblImpl.setHit(getHit());

		tblImpl.resetOriginalValues();

		return tblImpl;
	}

	@Override
	public int compareTo(TBL tbl) {
		long primaryKey = tbl.getPrimaryKey();

		if (getPrimaryKey() < primaryKey) {
			return -1;
		}
		else if (getPrimaryKey() > primaryKey) {
			return 1;
		}
		else {
			return 0;
		}
	}

	@Override
	public boolean equals(Object object) {
		if (this == object) {
			return true;
		}

		if (!(object instanceof TBL)) {
			return false;
		}

		TBL tbl = (TBL)object;

		long primaryKey = tbl.getPrimaryKey();

		if (getPrimaryKey() == primaryKey) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public int hashCode() {
		return (int)getPrimaryKey();
	}

	@Override
	public boolean isEntityCacheEnabled() {
		return _entityCacheEnabled;
	}

	@Override
	public boolean isFinderCacheEnabled() {
		return _finderCacheEnabled;
	}

	@Override
	public void resetOriginalValues() {
		_originalSubject = _subject;

		_originalWriter = _writer;

		_originalContents = _contents;

		_columnBitmask = 0;
	}

	@Override
	public CacheModel<TBL> toCacheModel() {
		TBLCacheModel tblCacheModel = new TBLCacheModel();

		tblCacheModel.bno = getBno();

		tblCacheModel.subject = getSubject();

		String subject = tblCacheModel.subject;

		if ((subject != null) && (subject.length() == 0)) {
			tblCacheModel.subject = null;
		}

		tblCacheModel.writer = getWriter();

		String writer = tblCacheModel.writer;

		if ((writer != null) && (writer.length() == 0)) {
			tblCacheModel.writer = null;
		}

		tblCacheModel.contents = getContents();

		String contents = tblCacheModel.contents;

		if ((contents != null) && (contents.length() == 0)) {
			tblCacheModel.contents = null;
		}

		tblCacheModel.regDate = getRegDate();

		String regDate = tblCacheModel.regDate;

		if ((regDate != null) && (regDate.length() == 0)) {
			tblCacheModel.regDate = null;
		}

		tblCacheModel.hit = getHit();

		return tblCacheModel;
	}

	@Override
	public String toString() {
		Map<String, Function<TBL, Object>> attributeGetterFunctions =
			getAttributeGetterFunctions();

		StringBundler sb = new StringBundler(
			(4 * attributeGetterFunctions.size()) + 2);

		sb.append("{");

		for (Map.Entry<String, Function<TBL, Object>> entry :
				attributeGetterFunctions.entrySet()) {

			String attributeName = entry.getKey();
			Function<TBL, Object> attributeGetterFunction = entry.getValue();

			sb.append(attributeName);
			sb.append("=");
			sb.append(attributeGetterFunction.apply((TBL)this));
			sb.append(", ");
		}

		if (sb.index() > 1) {
			sb.setIndex(sb.index() - 1);
		}

		sb.append("}");

		return sb.toString();
	}

	@Override
	public String toXmlString() {
		Map<String, Function<TBL, Object>> attributeGetterFunctions =
			getAttributeGetterFunctions();

		StringBundler sb = new StringBundler(
			(5 * attributeGetterFunctions.size()) + 4);

		sb.append("<model><model-name>");
		sb.append(getModelClassName());
		sb.append("</model-name>");

		for (Map.Entry<String, Function<TBL, Object>> entry :
				attributeGetterFunctions.entrySet()) {

			String attributeName = entry.getKey();
			Function<TBL, Object> attributeGetterFunction = entry.getValue();

			sb.append("<column><column-name>");
			sb.append(attributeName);
			sb.append("</column-name><column-value><![CDATA[");
			sb.append(attributeGetterFunction.apply((TBL)this));
			sb.append("]]></column-value></column>");
		}

		sb.append("</model>");

		return sb.toString();
	}

	private static class EscapedModelProxyProviderFunctionHolder {

		private static final Function<InvocationHandler, TBL>
			_escapedModelProxyProviderFunction = _getProxyProviderFunction();

	}

	private static boolean _entityCacheEnabled;
	private static boolean _finderCacheEnabled;

	private long _bno;
	private String _subject;
	private String _originalSubject;
	private String _writer;
	private String _originalWriter;
	private String _contents;
	private String _originalContents;
	private String _regDate;
	private int _hit;
	private long _columnBitmask;
	private TBL _escapedModel;

}